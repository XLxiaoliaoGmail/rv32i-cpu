# RISC-V RV32I 流水线CPU设计

## 项目简介
这是一个基于RISC-V-32I指令集的32位流水线CPU设计项目。采用SystemVerilog硬件描述语言实现，支持基础指令系统，实现了指令缓存和数据缓存，采用典型五级流水线设计，各模块间均通过请求-响应形式通信。

使用Modelsim进行了仿真验证，验证了算术运算、分支跳转以及内存访问操作。


## **数据通路**
  - 如下图所示，系统的功能部件均直接与控制单元通信，控制逻辑仅在控制单元内确定，保证了各单元的设计独立性和运行可靠性，详细介绍见下文。

  ![image](https://github.com/user-attachments/assets/af1d61ff-fc9c-4dd3-a420-8fe2b73fda86)


## **流水线执行**: 

控制单元是整个系统的核心，内部采用流水线形式执行，包含四个子单元，分别控制取指，译码，执行，访存和写回，一条指令的执行依次经过四个子单元。

子单元间使用握手形式通信，从上一单元的输出缓存读取数据，处理后再存入本单元的输出缓存，确保单元的设计独立性，并且有较高的可拓展性（例如可以拓展输出缓存）。

每个子控制单元的内部实现采用握手协议进行控制，包含以下信号接口：
   - 输入信号：pre-valid（前级数据有效）、pre-data（前级数据）、post-ready（后级就绪）
   - 输出信号：self-valid（本级数据有效）、self-data（本级数据）、self-ready（本级就绪）

控制流程：
   1. 复位或空闲时，将self-ready置1（表示可接收数据），self-valid置0（表示无有效数据）
   2. 等待前级数据有效（pre-valid=1）
   3. 取得数据后，将self-ready置0，开始处理前级数据
   4. 数据处理完成后，设置self-data并将self-valid置1
   5. 等待后级准备就绪（post-ready=1）且本级数据有效（self-valid=1），此时后级会取走数据，然后本级回到空闲状态

这种基于握手协议的设计确保了数据在流水线各级之间的可靠传输，并且模块的设计较为独立与便捷。

下面的控制逻辑图展示了一个子控制单元的工作流程。

![image](https://github.com/user-attachments/assets/116491fb-fed1-4cee-a630-e25f843d563e)

若遇到冒险，则会暂停某些前级单元，直到冒险解决再恢复运行，包括：
  1. 数据冒险：若EXECUTE与MEMORY欲写入的寄存器地址与DECODE欲读取的寄存器地址相同，则暂停DECODE。
  2. 控制冒险：若DECODE解析得到命令为跳转或分支，则暂停FETCH，直到PC值更新。
     
## **缓存**: 
  - 实现指令与数据缓存机制
  - 使用AXI协议与存储器通信
  - 指令缓存仅支持读取
  - 数据缓存可读写
  - 数据缓存模块运行描述如下图所示，指令缓存类似
  <img src="https://github.com/user-attachments/assets/d87043b4-989d-453e-8d69-1aa2a2666901" width="80%">
